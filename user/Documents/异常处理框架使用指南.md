# JiSpeed 异常处理框架使用指南

## 目录

1. [架构概述](#1-架构概述)
2. [异常处理结构](#2-异常处理结构)
3. [异常处理流程](#3-异常处理流程)
4. [使用指南](#4-使用指南)
   - [后端开发人员](#41-后端开发人员)
   - [前端开发人员](#42-前端开发人员)
5. [案例分析：骑手未找到](#5-案例分析骑手未找到)
6. [错误码规范](#6-错误码规范)
7. [扩展指南](#7-扩展指南)
8. [最佳实践](#8-最佳实践)
9. [常见问题解答](#9-常见问题解答)

## 1. 架构概述

JiSpeed的异常处理框架采用分层设计，实现了前后端分离、关注点分离和标准化错误处理：

- **Core层**：定义基础异常类型和错误码常量
- **API层**：通过全局中间件统一处理异常
- **前端层**：接收标准化错误响应并进行处理

这种设计使业务逻辑层可以专注于业务规则，API层专注于请求处理，前端专注于用户体验，同时保持错误处理的一致性和可维护性。

## 2. 异常处理结构

```
JISpeed.Core/
├── Constants/
│   └── ErrorCodes.cs              # 所有模块的错误码常量定义
├── Exceptions/
│   ├── BaseException.cs           # 异常基类
│   ├── BusinessException.cs       # 业务逻辑异常类
│   ├── ValidationException.cs     # 数据验证异常类
│   ├── NotFoundException.cs       # 资源未找到异常类
│   └── Modules/                   # 模块化异常工厂文件夹
│       ├── RiderExceptions.cs     # 骑手模块异常工厂
│       ├── OrderExceptions.cs     # 订单模块异常工厂
│       └── ...                    # 其他模块异常工厂

JISpeed.Api/
├── Common/
│   └── ApiResponse.cs             # 标准API响应类
└── Middleware/
    └── GlobalExceptionMiddleware.cs # 全局异常处理中间件
```

## 3. 异常处理流程

异常处理在JiSpeed系统中的流程如下：

1. **异常产生**：业务逻辑层检测到错误条件（如资源未找到、验证失败等）
2. **异常创建**：通过模块化异常工厂创建包含错误码和消息的异常对象
3. **异常抛出**：业务层将异常抛出，不进行捕获和处理
4. **中间件捕获**：GlobalExceptionMiddleware自动捕获所有未处理的异常
5. **异常转换**：中间件将异常转换为标准API响应格式（ApiResponse）
6. **状态码映射**：根据异常类型设置适当的HTTP状态码
7. **日志记录**：记录异常详情，包括请求信息和堆栈跟踪
8. **响应返回**：将标准化的错误响应返回给客户端
9. **前端处理**：前端根据错误码和消息执行相应的UI逻辑

## 4. 使用指南

### 4.1 后端开发人员

后端部分只需要在业务逻辑中抛出合适的异常，其余的处理将由框架自动完成。

#### 抛出异常（可以参考Application/Services/Rider/RiderService.cs）

在业务逻辑层（Service层）中，当检测到错误条件时，使用模块化的异常工厂创建并抛出异常（如果异常工厂里没有又暂时不想创建，也可以直接用异常类，RiderService.cs里面两种都有）：

```csharp
// 示例：检查骑手是否存在
if (rider == null)
{
    throw RiderExceptions.RiderNotFound(riderId);
}

// 示例：检查订单状态
if (order.Status != OrderStatus.Pending)
{
    throw OrderExceptions.OrderStatusError(
        orderId, 
        order.Status.ToString(), 
        OrderStatus.Pending.ToString()
    );
}
```

#### 控制器中的使用

控制器不需要手动处理异常，直接调用业务逻辑：

```csharp
[HttpGet("{id}")]
public async Task<ApiResponse<RiderDto>> GetRider(string id)
{
    // 直接调用业务服务，不需要try-catch
    // 如果发生异常，会被全局异常中间件自动捕获
    var rider = await _riderService.GetRiderByIdAsync(id);
    
    // 返回成功响应
    return ApiResponse<RiderDto>.Success(rider);
}
```

#### 添加新的错误码

如需添加新的错误码，请在`ErrorCodes.cs`文件中按模块分段添加常量定义。例如：

```csharp
// 订单模块错误码（20000-20999）
public const int OrderDeliveryTimeTooShort = 20008; // 订单配送时间过短
```

### 4.2 前端开发人员

前端部分需要处理从API接收到的标准错误响应。

#### 标准错误响应格式

```json
{
  "code": 10001,
  "message": "骑手 (ID: R12345) 未找到",
  "data": null,
  "timestamp": 1689413245789
}
```

- `code`: 错误码，非0值表示错误
- `message`: 错误描述信息
- `data`: 通常为null，某些情况下可能包含错误详情
- `timestamp`: 服务器处理时间戳

#### 处理错误响应

根据错误码执行不同的处理逻辑：

```javascript
// 发送API请求并处理响应
async function fetchData(url) {
  try {
    const response = await axios.get(url);
    
    // 检查响应中的错误码
    if (response.data.code !== 0) {
      // 处理业务错误
      handleApiError(response.data);
      return { success: false, error: response.data };
    }
    
    // 成功响应
    return { success: true, data: response.data.data };
  } catch (error) {
    // 处理HTTP错误或网络错误
    handleNetworkError(error);
    return { success: false, error: error.response?.data || error };
  }
}

// 处理API业务错误
function handleApiError(errorResponse) {
  const { code, message } = errorResponse;
  
  // 根据错误码进行处理
  switch (code) {
    case 10001: // RiderNotFound
      showNotification('error', message);
      navigateTo('/riders');
      break;
      
    case 2001: // Unauthorized
      showLoginPrompt();
      break;
      
    default:
      showNotification('error', message || '操作失败');
  }
}
```

#### 常见错误处理策略

1. **认证错误**：重定向到登录页面
2. **资源未找到**：显示错误消息并导航到列表页
3. **验证错误**：显示字段验证错误
4. **业务错误**：显示错误消息，可能需要刷新数据或提供重试选项
5. **系统错误**：显示通用错误消息，鼓励用户联系支持

## 5. 案例分析：骑手未找到

下面通过一个完整的案例来说明异常处理流程。假设用户尝试查看ID为"R12345"的骑手信息，但该骑手不存在。

### 后端流程

1. **控制器接收请求**

```csharp
// RidersController.cs
[HttpGet("{riderId}")]
public async Task<ActionResult<ApiResponse<RiderDTO>>> GetRider(string riderId)
{
    var rider = await _riderService.GetRiderByIdAsync(riderId);
    return Ok(ApiResponse<RiderDTO>.Success(rider));
}
```

2. **服务层检测错误并抛出异常**

```csharp
// RiderService.cs
public async Task<Rider> GetRiderByIdAsync(string riderId)
{
    var rider = await _riderRepository.GetByIdAsync(riderId);
    
    if (rider == null)
    {
        _logger.LogWarning("骑手不存在, RiderId: {RiderId}", riderId);
        throw RiderExceptions.RiderNotFound(riderId);
    }
    
    return rider;
}
```

3. **异常工厂创建异常对象**

```csharp
// RiderExceptions.cs
public static NotFoundException RiderNotFound(string riderId)
{
    return new NotFoundException(ErrorCodes.RiderNotFound, $"骑手 (ID: {riderId}) 未找到");
}
```

4. **全局异常中间件捕获异常**

`GlobalExceptionMiddleware`捕获未处理的`NotFoundException`，进行以下处理：
- 设置HTTP状态码为404
- 创建包含错误码10001的ApiResponse
- 记录警告级别日志
- 序列化响应并返回给客户端

5. **返回给客户端的响应**

```json
{
  "code": 10001,
  "message": "骑手 (ID: R12345) 未找到",
  "data": null,
  "timestamp": 1689413245789
}
```

### 前端流程

1. **发送请求**

```javascript
// 发送GET请求获取骑手信息
axios.get('/api/riders/R12345')
  .then(response => {
    // 处理成功响应
    displayRiderInfo(response.data.data);
  })
  .catch(error => {
    // 处理错误响应
    handleError(error.response.data);
  });
```

2. **接收错误响应**

前端接收到HTTP 404状态码和JSON错误响应。

3. **处理错误**

```javascript
function handleError(errorData) {
  const { code, message } = errorData;
  
  switch (code) {
    case 10001: // RiderNotFound
      // 显示友好的错误消息
      showErrorMessage(message);
      
      // 提供导航回骑手列表的选项
      showBackToListButton();
      
      // 记录错误日志
      console.log(`骑手查询错误: ${message}`);
      break;
      
    // 处理其他错误码...
    
    default:
      // 通用错误处理
      showErrorMessage("操作失败，请稍后重试");
  }
}
```

4. **用户界面反馈**

用户界面显示错误消息："骑手 (ID: R12345) 未找到"，并提供返回骑手列表的按钮。

## 6. 错误码规范

错误码采用模块分段设计，便于识别和管理：

### 通用错误 (1000-1999)
- **1000**: 一般错误
- **1001**: 验证失败
- **1002**: 缺少参数

### 认证与授权错误 (2000-2999)
- **2001**: 未授权
- **2002**: 禁止访问
- **2003**: 账号已禁用

### 骑手模块错误 (10000-10999)
- **10001**: 骑手未找到
- **10002**: 骑手状态错误
- **10003**: 骑手容量超限

### 订单模块错误 (20000-20999)
- **20001**: 订单未找到
- **20002**: 订单状态错误
- **20003**: 订单已取消

完整的错误码定义请参考`JISpeed.Core/Constants/ErrorCodes`类。

## 7. 扩展指南

### 添加新的异常工厂方法

为已有模块添加新的异常场景：

```csharp
// 在RiderExceptions.cs中添加新的异常工厂方法
public static BusinessException RiderDeviceOffline(string riderId, string deviceId)
{
    return new BusinessException(ErrorCodes.RiderDeviceOffline,
        $"骑手 (ID: {riderId}) 的设备 (ID: {deviceId}) 已离线");
}
```

### 添加新的模块异常工厂

创建新的模块异常工厂类：

```csharp
// 创建新文件：Core/Exceptions/Modules/CouponExceptions.cs
using JISpeed.Core.Constants;

namespace JISpeed.Core.Exceptions
{
    public class CouponExceptions
    {
        public static NotFoundException CouponNotFound(string couponId)
        {
            return new NotFoundException(ErrorCodes.CouponNotFound,
                $"优惠券 (ID: {couponId}) 未找到");
        }
        
        public static BusinessException CouponExpired(string couponId, DateTime expireTime)
        {
            return new BusinessException(ErrorCodes.CouponExpired,
                $"优惠券 (ID: {couponId}) 已于 {expireTime:yyyy-MM-dd HH:mm:ss} 过期");
        }
    }
}
```

## 8. 最佳实践

### 异常命名和消息

- 错误码应具有描述性，遵循模块分段原则
- 错误消息应清晰明了，包含必要的上下文信息
- 消息应面向最终用户，避免技术术语

### 异常粒度

- 为每种具体错误场景创建专门的异常方法
- 避免使用通用错误码，应使用模块特定的错误码

### 日志记录

- 业务异常通常记录为Information或Warning级别
- 系统异常记录为Error级别，包含完整堆栈跟踪
- 记录足够的上下文信息（请求路径、方法、IP等）

### 前端错误处理

- 为常见错误码创建统一的处理逻辑
- 对特定错误提供有意义的用户反馈和操作建议
- 在适当情况下提供重试操作或替代方案

## 9. 常见问题解答

### Q: 如何处理第三方API的异常？

**A**: 捕获第三方API异常并转换为我们的标准异常：

```csharp
try
{
    await _paymentGateway.ProcessPaymentAsync(request);
}
catch (PaymentGatewayException ex)
{
    // 转换为我们的标准异常
    throw PaymentExceptions.PaymentFailed(request.PaymentId, ex.Message);
}
```

### Q: 如何处理批量操作中的多个错误？

**A**: 收集所有错误并一次性返回：

```csharp
public async Task<BatchResult> ProcessBatchAsync(List<OrderRequest> requests)
{
    var result = new BatchResult();
    
    foreach (var request in requests)
    {
        try
        {
            var order = await _orderService.CreateOrderAsync(request);
            result.SuccessItems.Add(new BatchItemResult { Id = order.Id });
        }
        catch (BaseException ex)
        {
            result.FailedItems.Add(new BatchItemResult 
            { 
                Id = request.OrderId,
                ErrorCode = ex.ErrorCode,
                ErrorMessage = ex.Message
            });
        }
    }
    
    return result;
}
```

### Q: 如何处理验证错误？

**A**: 使用ValidationException或ModelState：

```csharp
// 在控制器中使用ModelState
if (!ModelState.IsValid)
{
    var errors = ModelState.ToDictionary(
        kvp => kvp.Key,
        kvp => kvp.Value.Errors.Select(e => e.ErrorMessage).ToArray()
    );
    
    throw CommonExceptions.ValidationFailed("请求参数验证失败", errors);
}
```

---
本文档旨在帮助开发人员理解和使用JiSpeed的异常处理框架。如有疑问或建议，请联系异常处理模块负责人xhr。
